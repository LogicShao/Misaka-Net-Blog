---
// Misaka Network - Tags Overview Page
import {getCollection} from 'astro:content';
import Layout from '../../layouts/Layout.astro';
import {tagHref} from '../../utils/tagHref';

// è·å–æ‰€æœ‰å·²å‘å¸ƒçš„åšå®¢æ–‡ç« 
const allPosts = await getCollection('blog', ({data}) => data.draft !== true);

// æå–æ‰€æœ‰æ ‡ç­¾å¹¶ç»Ÿè®¡æ–‡ç« æ•°é‡
const tagStats = new Map<string, number>();
allPosts.forEach(post => {
  const tags = post.data.tags || [];
  tags.forEach(tag => {
    tagStats.set(tag, (tagStats.get(tag) || 0) + 1);
  });
});

// è½¬æ¢ä¸ºæ•°ç»„å¹¶æŒ‰æ–‡ç« æ•°é‡é™åºæ’åº
const sortedTags = Array.from(tagStats.entries())
  .map(([tag, count]) => ({tag, count}))
  .sort((a, b) => b.count - a.count);

// è®¡ç®—æ€»æ ‡ç­¾æ•°å’Œæ€»æ–‡ç« æ•°
const totalTags = sortedTags.length;
const totalPosts = allPosts.length;
const hasTags = totalTags > 0;
const averagePostsPerTag = totalTags > 0 ? (totalPosts / totalTags).toFixed(1) : '0.0';
const topTag = hasTags ? sortedTags[0] : null;
const totalTagOccurrences = sortedTags.reduce((acc, {count}) => acc + count, 0);
const cumulativeShareData = (() => {
  let runningTotal = 0;
  return sortedTags.map(({count}, index) => {
    runningTotal += count;
    const percent = totalTagOccurrences > 0 ? (runningTotal / totalTagOccurrences) * 100 : 0;
    return {rank: index + 1, percent: Number(percent.toFixed(2))};
  });
})();

// ==================== è¯äº‘æ•°æ®ç”Ÿæˆ ====================
/**
 * æ¸…ç† Markdown è¯­æ³•
 */
function cleanMarkdown(text: string): string {
  if (!text) return '';

  return text
    // ç§»é™¤æ•°å­¦å…¬å¼ï¼ˆä¼˜å…ˆå¤„ç†ï¼Œé¿å…å¹²æ‰°å…¶ä»–è§„åˆ™ï¼‰
    .replace(/\$\$[\s\S]*?\$\$/g, ' ')  // å—çº§å…¬å¼ $$...$$
    .replace(/\$[^$]+\$/g, ' ')         // è¡Œå†…å…¬å¼ $...$

    // ç§»é™¤ä»£ç å—
    .replace(/```[\s\S]*?```/g, ' ')
    .replace(/`[^`]+`/g, ' ')

    // ç§»é™¤é“¾æ¥
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')

    // ç§»é™¤å›¾ç‰‡
    .replace(/!\[([^\]]*)\]\([^)]+\)/g, '$1')

    // ç§»é™¤æ ‡é¢˜æ ‡è®°
    .replace(/^#{1,6}\s+/gm, '')

    // ç§»é™¤ç²—ä½“/æ–œä½“
    .replace(/\*\*([^*]+)\*\*/g, '$1')
    .replace(/\*([^*]+)\*/g, '$1')
    .replace(/__([^_]+)__/g, '$1')
    .replace(/_([^_]+)_/g, '$1')

    // ç§»é™¤å¼•ç”¨
    .replace(/^>\s+/gm, '')

    // ç§»é™¤åˆ—è¡¨æ ‡è®°
    .replace(/^[-*+]\s+/gm, '')
    .replace(/^\d+\.\s+/gm, '')

    // ç§»é™¤ HTML æ ‡ç­¾
    .replace(/<[^>]+>/g, ' ')

    // ç§»é™¤å¤šä½™ç©ºç™½
    .replace(/\s+/g, ' ')
    .trim();
}

/**
 * ä¸­æ–‡åˆ†è¯è¾…åŠ©å‡½æ•°ï¼ˆç®€å•å®ç°ï¼‰
 * ä»æ–‡æœ¬ä¸­æå– 2-4 ä¸ªå­—çš„è¯ç»„
 */
function extractChineseWords(text: string): string[] {
  if (!text) return [];

  // å…ˆæ¸…ç† Markdown è¯­æ³•
  const cleanedText = cleanMarkdown(text);

  const words: string[] = [];
  const cleanText = cleanedText
    .replace(/[^\u4e00-\u9fa5a-zA-Z0-9]/g, ' ') // ä¿ç•™ä¸­æ–‡ã€è‹±æ–‡ã€æ•°å­—
    .replace(/\s+/g, ' ')
    .trim();

  // æå– 2-4 å­—çš„ä¸­æ–‡è¯ç»„
  const chars = cleanText.split('');
  for (let i = 0; i < chars.length; i++) {
    for (let len = 2; len <= 4 && i + len <= chars.length; len++) {
      const word = chars.slice(i, i + len).join('');
      if (/^[\u4e00-\u9fa5]{2,4}$/.test(word)) {
        words.push(word);
      }
    }
  }

  // æå–è‹±æ–‡å•è¯ï¼ˆ2ä¸ªå­—æ¯ä»¥ä¸Šï¼‰
  const englishWords = cleanText.match(/[a-zA-Z]{2,}/g) || [];
  words.push(...englishWords.map(w => w.toLowerCase()));

  return words;
}

/**
 * åœç”¨è¯åˆ—è¡¨ï¼ˆè¿‡æ»¤å¸¸è§æ— æ„ä¹‰è¯ï¼‰- æ‰©å±•ç‰ˆ
 */
const stopWords = new Set([
  // ä¸­æ–‡å¸¸è§è™šè¯
  'çš„', 'äº†', 'åœ¨', 'æ˜¯', 'æˆ‘', 'æœ‰', 'å’Œ', 'å°±', 'ä¸', 'äºº', 'éƒ½', 'ä¸€', 'ä¸€ä¸ª', 'ä¸€äº›',
  'ä¸Š', 'ä¹Ÿ', 'å¾ˆ', 'åˆ°', 'è¯´', 'è¦', 'å»', 'ä½ ', 'ä¼š', 'ç€', 'æ²¡æœ‰', 'çœ‹', 'å¥½', 'ä¸ª',
  'è‡ªå·±', 'è¿™', 'é‚£', 'é‡Œ', 'å°±æ˜¯', 'å¯ä»¥', 'è¿™ä¸ª', 'æ¥', 'ä¸', 'ä½†æ˜¯', 'æˆ–è€…', 'å¦‚æœ',
  'å› ä¸º', 'æ‰€ä»¥', 'è™½ç„¶', 'ç„¶è€Œ', 'ä½†', 'è€Œä¸”', 'å¹¶ä¸”', 'æˆ–', 'åˆ', 'åŠ', 'ä»¥åŠ',
  'ä»€ä¹ˆ', 'æ€ä¹ˆ', 'ä¸ºä»€ä¹ˆ', 'å“ªé‡Œ', 'å“ªä¸ª', 'æ€æ ·', 'å¦‚ä½•', 'å¤šå°‘', 'å‡ ä¸ª',
  'å¯èƒ½', 'åº”è¯¥', 'éœ€è¦', 'å¿…é¡»', 'èƒ½å¤Ÿ', 'å·²ç»', 'è¿˜æ˜¯', 'è¿˜æœ‰', 'åªæ˜¯', 'åªæœ‰',
  'æ¯”å¦‚', 'ä¾‹å¦‚', 'ç­‰ç­‰', 'ä¹‹ç±»', 'é€šè¿‡', 'å…³äº', 'å¯¹äº', 'æ ¹æ®', 'æŒ‰ç…§',
  'ä»–', 'å¥¹', 'å®ƒ', 'ä»–ä»¬', 'å¥¹ä»¬', 'å®ƒä»¬', 'æˆ‘ä»¬', 'ä½ ä»¬', 'å¤§å®¶',
  'è¿™äº›', 'é‚£äº›', 'è¿™æ ·', 'é‚£æ ·', 'æ€æ ·', 'å“ªäº›',
  'è¿›è¡Œ', 'å®ç°', 'ä½¿ç”¨', 'åŒ…æ‹¬', 'å…·æœ‰', 'å±äº', 'æˆä¸º', 'ä½œä¸º', 'ç”±äº',

  // LaTeX å¸¸è§å‘½ä»¤ï¼ˆé˜²æ­¢æ®‹ç•™ï¼‰
  'frac', 'text', 'left', 'right', 'cdot', 'times', 'div', 'sum', 'int',
  'infty', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'theta', 'lambda',
  'omega', 'sigma', 'sqrt', 'quad', 'qquad', 'geq', 'leq', 'neq', 'approx',
  'mathbf', 'mathrm', 'mathbb', 'mathcal', 'limits', 'displaystyle',

  // æŠ€æœ¯æ–‡æ¡£å¸¸è§è¯
  'ä»£ç ', 'ç¤ºä¾‹', 'å¦‚ä¸‹', 'ä¸‹é¢', 'ä¸Šé¢', 'æ¥ä¸‹æ¥', 'é¦–å…ˆ', 'å…¶æ¬¡', 'æœ€å',
  'æ³¨æ„', 'é‡è¦', 'æç¤º', 'è­¦å‘Š', 'å¤‡æ³¨',

  // è‹±æ–‡åœç”¨è¯
  'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with',
  'by', 'from', 'as', 'is', 'was', 'are', 'be', 'been', 'being', 'have', 'has', 'had',
  'do', 'does', 'did', 'will', 'would', 'should', 'can', 'could', 'may', 'might',
  'must', 'shall', 'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it',
  'we', 'they', 'what', 'which', 'who', 'when', 'where', 'why', 'how',
  'if', 'so', 'than', 'such', 'no', 'not', 'only', 'own', 'same', 'then', 'there',
  'their', 'them', 'some', 'all', 'each', 'few', 'more', 'most', 'other', 'into',
  'through', 'during', 'before', 'after', 'above', 'below', 'between', 'under',
  'again', 'further', 'once', 'here', 'both', 'very', 'too', 'also'
]);

/**
 * ç”Ÿæˆè¯äº‘æ•°æ®
 */
function generateWordCloudData() {
  const wordFreq = new Map<string, number>();

  allPosts.forEach((post) => {
    const {title, description, tags} = post.data;
    const body = post.body || ''; // è·å–æ–‡ç« æ­£æ–‡

    // 1. æ ‡ç­¾æƒé‡ï¼ˆÃ—3ï¼‰
    (tags || []).forEach(tag => {
      wordFreq.set(tag, (wordFreq.get(tag) || 0) + 3);
    });

    // 2. æ ‡é¢˜æƒé‡ï¼ˆÃ—2ï¼‰
    const titleWords = extractChineseWords(title);
    titleWords.forEach(word => {
      if (!stopWords.has(word)) {
        wordFreq.set(word, (wordFreq.get(word) || 0) + 2);
      }
    });

    // 3. æ­£æ–‡æƒé‡ï¼ˆÃ—2ï¼‰- æœ€é‡è¦çš„å†…å®¹æ¥æº
    if (body) {
      const bodyWords = extractChineseWords(body);
      bodyWords.forEach(word => {
        if (!stopWords.has(word)) {
          wordFreq.set(word, (wordFreq.get(word) || 0) + 2);
        }
      });
    }

    // 4. æè¿°æƒé‡ï¼ˆÃ—1ï¼‰
    const descWords = extractChineseWords(description || '');
    descWords.forEach(word => {
      if (!stopWords.has(word)) {
        wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
      }
    });
  });

  // è¿‡æ»¤ä½é¢‘è¯ï¼ˆé¢‘ç‡ < 3ï¼‰å¹¶è½¬æ¢ä¸ºè¯äº‘æ ¼å¼
  return Array.from(wordFreq.entries())
    .filter(([_, count]) => count >= 3)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 120) // å–å‰ 120 ä¸ªè¯
    .map(([word, count]) => [word, count] as [string, number]);
}

const wordCloudData = generateWordCloudData();
const hasWordCloudData = wordCloudData.length > 0;

// é¢„å®šä¹‰çš„æ ‡ç­¾é¢œè‰²æ–¹æ¡ˆï¼ˆå¾ªç¯ä½¿ç”¨ï¼‰
const colorSchemes = [
  {bg: 'rgba(74, 222, 128, 0.1)', border: 'rgba(74, 222, 128, 0.5)', text: '#4ade80', hover: 'rgba(74, 222, 128, 0.2)'}, // ç”µè·¯æ¿ç»¿
  {bg: 'rgba(56, 189, 248, 0.1)', border: 'rgba(56, 189, 248, 0.5)', text: '#38bdf8', hover: 'rgba(56, 189, 248, 0.2)'}, // è¾…åŠ©è“
  {bg: 'rgba(168, 85, 247, 0.1)', border: 'rgba(168, 85, 247, 0.5)', text: '#a855f7', hover: 'rgba(168, 85, 247, 0.2)'}, // ç´«è‰²
  {bg: 'rgba(251, 146, 60, 0.1)', border: 'rgba(251, 146, 60, 0.5)', text: '#fb923c', hover: 'rgba(251, 146, 60, 0.2)'},  // æ©™è‰²
  {bg: 'rgba(244, 63, 94, 0.1)', border: 'rgba(244, 63, 94, 0.5)', text: '#f43f5e', hover: 'rgba(244, 63, 94, 0.2)'},     // ç«çº¢
  {bg: 'rgba(34, 197, 94, 0.1)', border: 'rgba(34, 197, 94, 0.5)', text: '#22c55e', hover: 'rgba(34, 197, 94, 0.2)'},     // ç¿ ç»¿
];
---

<Layout
  title="æ ‡ç­¾å½’æ¡£ - Misaka Network"
  description={`æµè§ˆæ‰€æœ‰ ${totalTags} ä¸ªæ ‡ç­¾ï¼Œæ¶µç›– ${totalPosts} ç¯‡æ–‡ç« `}
>
  <!-- Page Header -->
  <div class="mb-12">
    <nav class="text-sm mb-6 font-mono" style="color: var(--text-muted);">
      <a href="/" class="hover:text-misaka-blue transition-colors">Home</a>
      <span class="mx-2">/</span>
      <a href="/blog" class="hover:text-misaka-blue transition-colors">Blog</a>
      <span class="mx-2">/</span>
      <span class="text-misaka-circuit">Tags</span>
    </nav>

    <div class="flex items-baseline space-x-4 mb-4">
      <h1 class="text-4xl md:text-5xl font-bold font-sans" style="color: var(--text-primary);">
        æ ‡ç­¾å½’æ¡£
      </h1>
      <div class="flex items-center space-x-2 text-sm font-mono" style="color: var(--text-muted);">
                <span
                  class="px-3 py-1 bg-misaka-circuit/20 border border-misaka-circuit/50 rounded-lg text-misaka-circuit">
                    {totalTags} ä¸ªæ ‡ç­¾
                </span>
        <span class="px-3 py-1 bg-misaka-blue/20 border border-misaka-blue/50 rounded-lg text-misaka-blue">
                    {totalPosts} ç¯‡æ–‡ç« 
                </span>
      </div>
    </div>

    <p class="text-lg font-mono" style="color: var(--text-muted);">
      // Explore topics by tags
    </p>

    <div class="divider-circuit mt-6"></div>
  </div>

  <!-- Statistics -->
  <div class="mb-12 network-panel">
    <h2 class="text-xl font-bold mb-6 font-sans" style="color: var(--text-primary);">
      ğŸ“Š æ ‡ç­¾ç»Ÿè®¡
    </h2>

    <!-- Stats Cards -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
      <div class="stat-item">
        <div class="stat-label">æœ€å¤šæ–‡ç« çš„æ ‡ç­¾</div>
        <div class="stat-value">
          {topTag ? (
            <>
              <a href={tagHref(topTag.tag)} class="hover:text-misaka-circuit transition-colors">
                #{topTag.tag}
              </a>
              <span class="stat-count">({topTag.count} ç¯‡)</span>
            </>
          ) : (
            <span class="text-sm" style="color: var(--text-muted);">
              æš‚æ— 
            </span>
          )}
        </div>
      </div>

      <div class="stat-item">
        <div class="stat-label">æ ‡ç­¾æ€»æ•°</div>
        <div class="stat-value">
          {totalTags} ä¸ª
        </div>
      </div>

      <div class="stat-item">
        <div class="stat-label">å¹³å‡æ¯ä¸ªæ ‡ç­¾</div>
        <div class="stat-value">
          {averagePostsPerTag} ç¯‡
        </div>
      </div>
    </div>

    <!-- Chart Container -->
    {hasTags && (
      <div class="chart-container">
        <h3 class="text-lg font-semibold mb-4 font-sans" style="color: var(--text-secondary);">
          æ ‡ç­¾åˆ†å¸ƒ (Top 10)
        </h3>
        <div class="chart-wrapper">
          <canvas id="tagChart"></canvas>
        </div>
      </div>
    )}

    {hasTags && (
      <div class="chart-container">
        <h3 class="text-lg font-semibold mb-2 font-sans" style="color: var(--text-secondary);">
          æ ‡ç­¾ç´¯è®¡å æ¯”æ›²çº¿
        </h3>
        <p class="text-sm mb-4 font-mono" style="color: var(--text-muted);">
          æŒ‰æ ‡ç­¾å‡ºç°æ¬¡æ•°æ’åºï¼Œæ›²çº¿è¡¨ç¤ºç´¯è®¡å æ¯”
        </p>
        <div class="chart-wrapper">
          <canvas id="tagCumulativeChart"></canvas>
        </div>
      </div>
    )}
  </div>

  <!-- Word Cloud Section -->
  {hasWordCloudData ? (
    <div class="mb-12 mt-12 network-panel">
      <h2 class="text-xl font-bold mb-6 font-sans" style="color: var(--text-primary);">
        â˜ï¸ å†…å®¹è¯äº‘
      </h2>
      <p class="text-sm mb-6" style="color: var(--text-muted);">
        åŸºäºæ‰€æœ‰æ–‡ç« çš„æ­£æ–‡ã€æ ‡ç­¾ã€æ ‡é¢˜å’Œæè¿°ç”Ÿæˆï¼Œè¯çš„å¤§å°åæ˜ å‡ºç°é¢‘ç‡ï¼ˆæ­£æ–‡æƒé‡æœ€é«˜ï¼‰
      </p>

      <!-- Word Cloud Canvas -->
      <div class="wordcloud-container">
        <canvas id="wordCloudCanvas"></canvas>
      </div>
    </div>
  ) : (
    <div class="mb-12 mt-12 network-panel text-center py-12">
      <p class="text-lg" style="color: var(--text-muted);">
        æš‚æ— è¶³å¤Ÿå†…å®¹ç”Ÿæˆè¯äº‘
      </p>
    </div>
  )}

  <!-- Tags Grid -->
  <div class="mb-8">
    <h2 class="text-xl font-bold mb-6 font-sans" style="color: var(--text-primary);">
      ğŸ·ï¸ æ‰€æœ‰æ ‡ç­¾
    </h2>
  </div>

  {hasTags && (
    <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
      {sortedTags.map(({tag, count}, index) => {
        const colorScheme = colorSchemes[index % colorSchemes.length];
        return (
          <a
            href={tagHref(tag)}
            class="tag-card group"
            style={`
                            --tag-bg: ${colorScheme.bg};
                            --tag-border: ${colorScheme.border};
                            --tag-text: ${colorScheme.text};
                            --tag-hover: ${colorScheme.hover};
                        `}
          >
            <div class="tag-card-content">
              <div class="tag-icon">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z"/>
                </svg>
              </div>
              <div class="tag-info">
                <h3 class="tag-name">
                  #{tag}
                </h3>
                <p class="tag-count">
                  {count} {count === 1 ? 'ç¯‡æ–‡ç« ' : 'ç¯‡æ–‡ç« '}
                </p>
              </div>
              <div class="tag-arrow">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                </svg>
              </div>
            </div>
          </a>
        );
      })}
    </div>
  )}

  {!hasTags && (
    <div class="network-panel text-center py-12">
      <p class="text-lg" style="color: var(--text-muted);">
        æš‚æ— æ ‡ç­¾æ•°æ®
      </p>
    </div>
  )}

  <!-- Back Link -->
  <div class="mt-12 text-center">
    <a
      href="/blog"
      class="inline-flex items-center space-x-2 text-misaka-blue hover:text-misaka-accent transition-colors font-mono"
    >
      <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18"/>
      </svg>
      <span>è¿”å›åšå®¢åˆ—è¡¨</span>
    </a>
  </div>
</Layout>

<!-- WordCloud2.js (æœ¬åœ°æ–‡ä»¶) -->
<script is:inline src="/wordcloud2.js"></script>

<!-- Chart.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<!-- Word Cloud Initialization Script - Enhanced -->
<script define:vars={{wordCloudData}}>
  // åˆå§‹åŒ–è¯äº‘çš„å‡½æ•°ï¼ˆæ”¯æŒ View Transitionsï¼‰
  function initializeWordCloud() {
    console.log('[WordCloud] Initializing...');

    const canvas = document.getElementById('wordCloudCanvas');
    if (!canvas) {
      console.error('[WordCloud] Canvas not found');
      return;
    }

    // ç­‰å¾… WordCloud åº“åŠ è½½
    function initWhenReady() {
      // æ£€æŸ¥ window.WordCloud æ˜¯å¦å­˜åœ¨
      if (typeof window.WordCloud === 'undefined') {
        console.log('[WordCloud] Waiting for library...', typeof window.WordCloud);
        setTimeout(initWhenReady, 100);
        return;
      }

      console.log('[WordCloud] Library loaded successfully');
      console.log('[WordCloud] Data length:', wordCloudData.length);
      console.log('[WordCloud] First 5 items:', wordCloudData.slice(0, 5));

      // è·å–å½“å‰ä¸»é¢˜
      const isDark = document.documentElement.classList.contains('dark');

      // ä¸»é¢˜é¢œè‰²é…ç½® - å¢å¼ºç‰ˆæ¸å˜è‰²ç³»
      const colors = isDark
        ? [
          '#4ade80', '#22c55e', '#10b981', '#34d399',  // ç»¿è‰²ç³»
          '#38bdf8', '#0ea5e9', '#06b6d4', '#22d3ee',  // è“è‰²ç³»
          '#a855f7', '#9333ea', '#c084fc', '#d946ef',  // ç´«è‰²ç³»
          '#fb923c', '#f97316', '#fb7185', '#fbbf24'   // æš–è‰²ç³»
        ]
        : [
          '#22c55e', '#16a34a', '#15803d', '#059669',  // ç»¿è‰²ç³»
          '#3b82f6', '#2563eb', '#1d4ed8', '#0284c7',  // è“è‰²ç³»
          '#8b5cf6', '#7c3aed', '#a855f7', '#c026d3',  // ç´«è‰²ç³»
          '#f97316', '#ea580c', '#dc2626', '#d97706'   // æš–è‰²ç³»
        ];

      // æ™ºèƒ½é¢œè‰²å‡½æ•° - æ ¹æ®è¯é¢‘è°ƒæ•´é¢œè‰²äº®åº¦
      function smartColor(word, weight) {
        const maxWeight = Math.max(...wordCloudData.map(item => item[1]));
        const minWeight = Math.min(...wordCloudData.map(item => item[1]));
        const normalizedWeight = (weight - minWeight) / (maxWeight - minWeight);

        // é«˜é¢‘è¯ä½¿ç”¨æ›´äº®çš„é¢œè‰²
        const colorIndex = Math.floor(normalizedWeight * (colors.length - 1));
        return colors[colorIndex] || colors[0];
      }

      // åˆå§‹åŒ–è¯äº‘
      function initWordCloud() {
        // è·å–è®¾å¤‡åƒç´ æ¯”ï¼ˆæ”¯æŒé«˜DPIå±å¹•ï¼‰
        const dpr = window.devicePixelRatio || 1;
        console.log('[WordCloud] Device Pixel Ratio (DPI Scale):', dpr);

        // è®¾ç½® canvas ç‰©ç†å°ºå¯¸
        const container = canvas.parentElement;
        const width = container.clientWidth;
        const height = 500; // å¢åŠ é«˜åº¦ä»¥è·å¾—æ›´å¥½çš„è§†è§‰æ•ˆæœ

        // è®¾ç½® canvas çš„æ˜¾ç¤ºå°ºå¯¸ï¼ˆCSSï¼‰
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        // è®¾ç½® canvas çš„å®é™…å°ºå¯¸ï¼ˆé«˜DPIæ”¯æŒï¼‰
        canvas.width = width * dpr;
        canvas.height = height * dpr;

        // ç¼©æ”¾ç»˜å›¾ä¸Šä¸‹æ–‡ä»¥åŒ¹é…è®¾å¤‡åƒç´ æ¯”
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);

        console.log('[WordCloud] Canvas size:', {
          cssWidth: width,
          cssHeight: height,
          physicalWidth: canvas.width,
          physicalHeight: canvas.height,
          dpr: dpr
        });

        // æ¸…ç©ºç”»å¸ƒ
        ctx.clearRect(0, 0, width, height);

        // æ·»åŠ åŠ è½½åŠ¨ç”»
        canvas.parentElement.style.opacity = '0.6';
        canvas.parentElement.style.transition = 'opacity 0.5s ease';

        try {
          // æ¸²æŸ“è¯äº‘
          window.WordCloud(canvas, {
            list: wordCloudData,

            // ç½‘æ ¼å¤§å°ï¼ˆå‡å°ä»¥å¢åŠ å¯†åº¦ï¼‰
            gridSize: Math.round(6 * width / 1024),

            // å­—ä½“å¤§å°è®¡ç®—ï¼ˆå¢åŠ å°ºå¯¸èŒƒå›´ï¼‰
            weightFactor: function (size) {
              const maxSize = Math.max(...wordCloudData.map(item => item[1]));
              const minSize = Math.min(...wordCloudData.map(item => item[1]));
              const normalized = (size - minSize) / (maxSize - minSize);
              // åŸºç¡€å¤§å° + åŠ¨æ€èŒƒå›´
              const baseSize = width / 1024 * 15;
              const sizeRange = width / 1024 * 35;
              return baseSize + Math.pow(normalized, 0.5) * sizeRange;
            },

            // å­—ä½“è®¾ç½®
            fontFamily: 'Inter, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif',
            fontWeight: function (word, weight) {
              // é«˜é¢‘è¯ä½¿ç”¨ç²—ä½“
              const maxWeight = Math.max(...wordCloudData.map(item => item[1]));
              return weight > maxWeight * 0.7 ? '700' : '600';
            },

            // é¢œè‰²å‡½æ•°
            color: function (word, weight) {
              return smartColor(word, weight);
            },

            // èƒŒæ™¯é€æ˜
            backgroundColor: 'transparent',

            // æ—‹è½¬è®¾ç½®ï¼ˆå‡å°‘æ—‹è½¬ä»¥æé«˜å¯è¯»æ€§ï¼‰
            rotateRatio: 0.15,
            rotationSteps: 2,
            minRotation: -Math.PI / 8,
            maxRotation: Math.PI / 8,

            // å¸ƒå±€ä¼˜åŒ–
            shuffle: true,
            shrinkToFit: true,
            drawOutOfBound: false,
            ellipticity: 0.75, // è°ƒæ•´æ¤­åœ†åº¦ï¼ˆ0.75 æ›´æ¥è¿‘åœ†å½¢ï¼Œè¯äº‘æ›´ç´§å‡‘ï¼‰

            // è¯äº‘ä¸­å¿ƒç‚¹ï¼ˆç”»å¸ƒä¸­å¿ƒï¼‰
            origin: [width / 2, height / 2],

            // æ¸…ç©ºç”»å¸ƒ
            clearCanvas: true,

            // æœ€å°å­—ä½“å¤§å°ï¼ˆç¡®ä¿å°è¯ä¹Ÿèƒ½æ˜¾ç¤ºï¼‰
            minSize: Math.max(8, width / 1024 * 10),

            // ç‚¹å‡»äº‹ä»¶ï¼ˆå¯é€‰ï¼‰
            click: function (item) {
              if (item && item[0]) {
                console.log('[WordCloud] Clicked:', item[0], 'Weight:', item[1]);
                // å¯ä»¥æ·»åŠ æœç´¢åŠŸèƒ½
                // window.location.href = `/search?q=${encodeURIComponent(item[0])}`;
              }
            },

            // hoveræ•ˆæœï¼ˆå¯é€‰ï¼‰
            hover: function (item, dimension, event) {
              if (item) {
                canvas.style.cursor = 'pointer';
              } else {
                canvas.style.cursor = 'default';
              }
            }
          });

          console.log('[WordCloud] Rendered successfully');

          // æ¸²æŸ“å®Œæˆåæ·¡å…¥åŠ¨ç”»
          setTimeout(() => {
            canvas.parentElement.style.opacity = '1';
          }, 100);

        } catch (error) {
          console.error('[WordCloud] Render error:', error);
          canvas.parentElement.style.opacity = '1';
        }
      }

      // åˆå§‹åŒ–
      initWordCloud();

      // å“åº”çª—å£å¤§å°å˜åŒ–ï¼ˆé˜²æŠ–ï¼‰
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          initWordCloud();
        }, 300);
      });

      // ç›‘å¬ä¸»é¢˜åˆ‡æ¢
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (mutation.attributeName === 'class') {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            initWordCloud();
          }
        });
      });

      observer.observe(document.documentElement, {
        attributes: true,
        attributeFilter: ['class']
      });
    }

    // å¼€å§‹åˆå§‹åŒ–
    initWhenReady();
  }

  // é¦–æ¬¡åŠ è½½ - ç­‰å¾…æ‰€æœ‰å¤–éƒ¨èµ„æºåŠ è½½å®Œæˆ
  window.addEventListener('load', initializeWordCloud);

  // View Transitions æ”¯æŒ
  document.addEventListener('astro:page-load', initializeWordCloud);
</script>

<!-- Chart Initialization Script -->
<script define:vars={{sortedTags: sortedTags.slice(0, 10)}}>
  // ä¿å­˜å›¾è¡¨å®ä¾‹ï¼ˆé¿å…é‡å¤åˆ›å»ºï¼‰
  let chartInstance = null;

  // åˆå§‹åŒ–å›¾è¡¨çš„å‡½æ•°ï¼ˆæ”¯æŒ View Transitionsï¼‰
  function initializeChart() {
    const canvas = document.getElementById('tagChart');
    if (!canvas) return;

    // å¦‚æœå·²æœ‰å›¾è¡¨å®ä¾‹ï¼Œå…ˆé”€æ¯
    if (chartInstance) {
      chartInstance.destroy();
      chartInstance = null;
    }

    // è·å–å½“å‰ä¸»é¢˜
    const isDark = document.documentElement.classList.contains('dark');

    // ä¸»é¢˜é¢œè‰²é…ç½®
    const colors = {
      primary: isDark ? '#4ade80' : '#22c55e',
      secondary: isDark ? '#38bdf8' : '#3b82f6',
      text: isDark ? '#f0f8ff' : '#0f172a',
      grid: isDark ? 'rgba(148, 163, 184, 0.1)' : 'rgba(148, 163, 184, 0.2)',
      background: isDark ? 'rgba(74, 222, 128, 0.1)' : 'rgba(74, 222, 128, 0.2)',
      border: isDark ? 'rgba(74, 222, 128, 0.5)' : 'rgba(74, 222, 128, 0.7)',
    };

    // å‡†å¤‡å›¾è¡¨æ•°æ®
    const labels = sortedTags.map(item => item.tag);
    const data = sortedTags.map(item => item.count);

    // åˆ›å»ºæ¸å˜è‰²
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
    gradient.addColorStop(0, colors.primary);
    gradient.addColorStop(1, colors.secondary);

    // åˆå§‹åŒ–å›¾è¡¨
    chartInstance = new Chart(ctx, {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'æ–‡ç« æ•°é‡',
          data: data,
          backgroundColor: colors.background,
          borderColor: colors.border,
          borderWidth: 2,
          borderRadius: 6,
          hoverBackgroundColor: colors.primary + '40',
          hoverBorderColor: colors.primary,
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: 2,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            backgroundColor: isDark ? 'rgba(30, 41, 59, 0.95)' : 'rgba(255, 255, 255, 0.95)',
            titleColor: colors.text,
            bodyColor: colors.text,
            borderColor: colors.border,
            borderWidth: 1,
            padding: 12,
            displayColors: false,
            callbacks: {
              title: (items) => `#${items[0].label}`,
              label: (item) => `${item.parsed.y} ç¯‡æ–‡ç« `
            }
          }
        },
        scales: {
          x: {
            grid: {
              display: false
            },
            ticks: {
              color: colors.text,
              font: {
                size: 12
              },
              maxRotation: 45,
              minRotation: 45
            }
          },
          y: {
            beginAtZero: true,
            grid: {
              color: colors.grid,
              drawBorder: false
            },
            ticks: {
              color: colors.text,
              font: {
                size: 12
              },
              stepSize: 1,
              precision: 0
            }
          }
        }
      }
    });

    // ç›‘å¬ä¸»é¢˜åˆ‡æ¢
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          const newIsDark = document.documentElement.classList.contains('dark');

          // æ›´æ–°é¢œè‰²
          const newColors = {
            primary: newIsDark ? '#4ade80' : '#22c55e',
            secondary: newIsDark ? '#38bdf8' : '#3b82f6',
            text: newIsDark ? '#f0f8ff' : '#0f172a',
            grid: newIsDark ? 'rgba(148, 163, 184, 0.1)' : 'rgba(148, 163, 184, 0.2)',
            background: newIsDark ? 'rgba(74, 222, 128, 0.1)' : 'rgba(74, 222, 128, 0.2)',
            border: newIsDark ? 'rgba(74, 222, 128, 0.5)' : 'rgba(74, 222, 128, 0.7)',
          };

          // æ›´æ–°å›¾è¡¨é…ç½®
          chartInstance.data.datasets[0].backgroundColor = newColors.background;
          chartInstance.data.datasets[0].borderColor = newColors.border;
          chartInstance.data.datasets[0].hoverBackgroundColor = newColors.primary + '40';
          chartInstance.data.datasets[0].hoverBorderColor = newColors.primary;

          chartInstance.options.plugins.tooltip.backgroundColor = newIsDark ? 'rgba(30, 41, 59, 0.95)' : 'rgba(255, 255, 255, 0.95)';
          chartInstance.options.plugins.tooltip.titleColor = newColors.text;
          chartInstance.options.plugins.tooltip.bodyColor = newColors.text;
          chartInstance.options.plugins.tooltip.borderColor = newColors.border;

          chartInstance.options.scales.x.ticks.color = newColors.text;
          chartInstance.options.scales.y.ticks.color = newColors.text;
          chartInstance.options.scales.y.grid.color = newColors.grid;

          chartInstance.update();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });
  }

  // é¦–æ¬¡åŠ è½½ - ç­‰å¾…æ‰€æœ‰å¤–éƒ¨èµ„æºåŠ è½½å®Œæˆ
  window.addEventListener('load', initializeChart);

  // View Transitions æ”¯æŒ
  document.addEventListener('astro:page-load', initializeChart);
</script>

<!-- Cumulative Share Chart Initialization Script -->
<script define:vars={{cumulativeShareData}}>
  // ä¿å­˜ç´¯è®¡å æ¯”å›¾è¡¨å®ä¾‹ï¼ˆé¿å…é‡å¤åˆ›å»ºï¼‰
  let cumulativeChartInstance = null;

  // åˆå§‹åŒ–ç´¯è®¡å æ¯”å›¾è¡¨çš„å‡½æ•°ï¼ˆæ”¯æŒ View Transitionsï¼‰
  function initializeCumulativeChart() {
    const canvas = document.getElementById('tagCumulativeChart');
    if (!canvas || cumulativeShareData.length === 0) return;

    // å¦‚æœå·²æœ‰å›¾è¡¨å®ä¾‹ï¼Œå…ˆé”€æ¯
    if (cumulativeChartInstance) {
      cumulativeChartInstance.destroy();
      cumulativeChartInstance = null;
    }

    // è·å–å½“å‰ä¸»é¢˜
    const isDark = document.documentElement.classList.contains('dark');

    // ä¸»é¢˜é¢œè‰²é…ç½®
    const colors = {
      primary: isDark ? '#4ade80' : '#22c55e',
      secondary: isDark ? '#38bdf8' : '#3b82f6',
      text: isDark ? '#f0f8ff' : '#0f172a',
      grid: isDark ? 'rgba(148, 163, 184, 0.1)' : 'rgba(148, 163, 184, 0.2)',
      fill: isDark ? 'rgba(74, 222, 128, 0.15)' : 'rgba(34, 197, 94, 0.12)',
    };

    // å‡†å¤‡å›¾è¡¨æ•°æ®
    const labels = cumulativeShareData.map(item => item.rank);
    const data = cumulativeShareData.map(item => item.percent);

    const ctx = canvas.getContext('2d');
    const gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
    gradient.addColorStop(0, colors.primary);
    gradient.addColorStop(1, colors.secondary);

    // åˆå§‹åŒ–å›¾è¡¨
    cumulativeChartInstance = new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          label: 'ç´¯è®¡å æ¯”',
          data: data,
          borderColor: gradient,
          backgroundColor: colors.fill,
          borderWidth: 2,
          pointRadius: 2,
          pointHoverRadius: 4,
          tension: 0.35,
          fill: true,
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: true,
        aspectRatio: 2,
        plugins: {
          legend: {
            display: false
          },
          tooltip: {
            backgroundColor: isDark ? 'rgba(30, 41, 59, 0.95)' : 'rgba(255, 255, 255, 0.95)',
            titleColor: colors.text,
            bodyColor: colors.text,
            borderColor: colors.primary,
            borderWidth: 1,
            padding: 12,
            displayColors: false,
            callbacks: {
              title: (items) => `Top ${items[0].label}`,
              label: (item) => `ç´¯è®¡å æ¯” ${item.parsed.y}%`
            }
          }
        },
        scales: {
          x: {
            grid: {
              display: false
            },
            ticks: {
              color: colors.text,
              font: {
                size: 12
              },
              autoSkip: true,
              maxTicksLimit: 10
            }
          },
          y: {
            beginAtZero: true,
            suggestedMax: 100,
            grid: {
              color: colors.grid,
              drawBorder: false
            },
            ticks: {
              color: colors.text,
              font: {
                size: 12
              },
              callback: (value) => `${value}%`
            }
          }
        }
      }
    });

    // ç›‘å¬ä¸»é¢˜åˆ‡æ¢
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.attributeName === 'class') {
          const newIsDark = document.documentElement.classList.contains('dark');

          const newColors = {
            primary: newIsDark ? '#4ade80' : '#22c55e',
            secondary: newIsDark ? '#38bdf8' : '#3b82f6',
            text: newIsDark ? '#f0f8ff' : '#0f172a',
            grid: newIsDark ? 'rgba(148, 163, 184, 0.1)' : 'rgba(148, 163, 184, 0.2)',
            fill: newIsDark ? 'rgba(74, 222, 128, 0.15)' : 'rgba(34, 197, 94, 0.12)',
          };

          const newGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
          newGradient.addColorStop(0, newColors.primary);
          newGradient.addColorStop(1, newColors.secondary);

          cumulativeChartInstance.data.datasets[0].borderColor = newGradient;
          cumulativeChartInstance.data.datasets[0].backgroundColor = newColors.fill;

          cumulativeChartInstance.options.plugins.tooltip.backgroundColor = newIsDark ? 'rgba(30, 41, 59, 0.95)' : 'rgba(255, 255, 255, 0.95)';
          cumulativeChartInstance.options.plugins.tooltip.titleColor = newColors.text;
          cumulativeChartInstance.options.plugins.tooltip.bodyColor = newColors.text;
          cumulativeChartInstance.options.plugins.tooltip.borderColor = newColors.primary;

          cumulativeChartInstance.options.scales.x.ticks.color = newColors.text;
          cumulativeChartInstance.options.scales.y.ticks.color = newColors.text;
          cumulativeChartInstance.options.scales.y.grid.color = newColors.grid;

          cumulativeChartInstance.update();
        }
      });
    });

    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class']
    });
  }

  // é¦–æ¬¡åŠ è½½ - ç­‰å¾…æ‰€æœ‰å¤–éƒ¨èµ„æºåŠ è½½å®Œæˆ
  window.addEventListener('load', initializeCumulativeChart);

  // View Transitions æ”¯æŒ
  document.addEventListener('astro:page-load', initializeCumulativeChart);
</script>

<style>
  /* è¯äº‘å®¹å™¨æ ·å¼ - å¢å¼ºç‰ˆ */
  .wordcloud-container {
    position: relative;
    width: 100%;
    height: 500px;
    background: linear-gradient(135deg,
    var(--bg-secondary) 0%,
    var(--bg-primary) 100%);
    border: 2px solid var(--border-color);
    border-radius: 16px;
    overflow: hidden;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
  }

  .wordcloud-container::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle,
    rgba(74, 222, 128, 0.03) 0%,
    transparent 70%);
    animation: wordcloud-glow 8s ease-in-out infinite;
    pointer-events: none;
  }

  @keyframes wordcloud-glow {
    0%, 100% {
      transform: translate(0, 0) scale(1);
    }
    50% {
      transform: translate(5%, 5%) scale(1.1);
    }
  }

  .wordcloud-container:hover {
    border-color: rgba(74, 222, 128, 0.6);
    box-shadow: 0 8px 24px rgba(74, 222, 128, 0.15),
    0 0 0 1px rgba(74, 222, 128, 0.1),
    inset 0 1px 0 rgba(255, 255, 255, 0.05);
    transform: translateY(-2px);
  }

  #wordCloudCanvas {
    display: block;
    width: 100% !important;
    height: 100% !important;
    position: relative;
    z-index: 1;
  }

  /* æ·»åŠ åŠ è½½æç¤º */
  .wordcloud-container::after {
    content: 'è¯äº‘ç”Ÿæˆä¸­...';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: var(--text-muted);
    font-size: 0.875rem;
    font-family: var(--font-mono);
    opacity: 0;
    transition: opacity 0.3s ease;
    pointer-events: none;
    z-index: 0;
  }

  .wordcloud-container[data-loading="true"]::after {
    opacity: 1;
  }

  /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
  @media (max-width: 768px) {
    .wordcloud-container {
      height: 400px;
      border-radius: 12px;
    }
  }

  @media (max-width: 480px) {
    .wordcloud-container {
      height: 350px;
    }
  }

  /* æ·±è‰²æ¨¡å¼å¢å¼º */
  :global(.dark) .wordcloud-container {
    background: linear-gradient(135deg,
    rgba(30, 41, 59, 0.8) 0%,
    rgba(15, 23, 42, 0.9) 100%);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3),
    inset 0 1px 0 rgba(74, 222, 128, 0.05);
  }

  :global(.dark) .wordcloud-container::before {
    background: radial-gradient(circle,
    rgba(74, 222, 128, 0.05) 0%,
    transparent 70%);
  }

  :global(.dark) .wordcloud-container:hover {
    border-color: rgba(74, 222, 128, 0.4);
    box-shadow: 0 8px 24px rgba(74, 222, 128, 0.2),
    0 0 0 1px rgba(74, 222, 128, 0.2),
    inset 0 1px 0 rgba(74, 222, 128, 0.1);
  }

  /* å›¾è¡¨å®¹å™¨æ ·å¼ */
  .chart-container {
    margin-top: 1rem;
    padding: 1.5rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 12px;
    transition: all 0.3s ease;
  }

  .chart-container:hover {
    border-color: rgba(74, 222, 128, 0.4);
    box-shadow: 0 4px 12px rgba(74, 222, 128, 0.1);
  }

  .chart-wrapper {
    position: relative;
    width: 100%;
    max-width: 100%;
    margin: 0 auto;
  }

  @media (max-width: 768px) {
    .chart-container {
      padding: 1rem;
    }

    .chart-wrapper {
      max-width: 100%;
    }
  }

  /* æ ‡ç­¾å¡ç‰‡æ ·å¼ */
  .tag-card {
    display: block;
    text-decoration: none;
    background: var(--tag-bg);
    border: 1px solid var(--tag-border);
    border-radius: 12px;
    padding: 1.25rem;
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }

  .tag-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--tag-hover);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: 0;
  }

  .tag-card:hover::before {
    opacity: 1;
  }

  .tag-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    border-color: var(--tag-text);
  }

  .tag-card-content {
    position: relative;
    z-index: 1;
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .tag-icon {
    flex-shrink: 0;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--bg-secondary);
    border-radius: 8px;
    color: var(--tag-text);
    transition: all 0.3s ease;
  }

  .tag-card:hover .tag-icon {
    transform: rotate(12deg) scale(1.1);
    background: var(--tag-text);
    color: var(--bg-primary);
  }

  .tag-info {
    flex: 1;
    min-width: 0;
  }

  .tag-name {
    font-size: 1.125rem;
    font-weight: 600;
    color: var(--tag-text);
    margin: 0;
    line-height: 1.4;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .tag-count {
    font-size: 0.875rem;
    color: var(--text-muted);
    margin: 0;
    margin-top: 0.25rem;
  }

  .tag-arrow {
    flex-shrink: 0;
    color: var(--tag-text);
    opacity: 0;
    transform: translateX(-8px);
    transition: all 0.3s ease;
  }

  .tag-card:hover .tag-arrow {
    opacity: 1;
    transform: translateX(0);
  }

  /* ç»Ÿè®¡é¡¹æ ·å¼ */
  .stat-item {
    text-align: center;
    padding: 1.5rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    transition: all 0.3s ease;
  }

  .stat-item:hover {
    border-color: var(--misaka-circuit);
    box-shadow: 0 4px 12px rgba(74, 222, 128, 0.1);
  }

  .stat-label {
    font-size: 0.875rem;
    color: var(--text-muted);
    margin-bottom: 0.5rem;
  }

  .stat-value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--text-primary);
  }

  .stat-count {
    font-size: 1rem;
    color: var(--text-muted);
    font-weight: 400;
    margin-left: 0.5rem;
  }

  /* å“åº”å¼ä¼˜åŒ– */
  @media (max-width: 640px) {
    .tag-card {
      padding: 1rem;
    }

    .tag-icon {
      width: 36px;
      height: 36px;
    }

    .tag-name {
      font-size: 1rem;
    }

    .tag-count {
      font-size: 0.75rem;
    }

    .stat-value {
      font-size: 1.25rem;
    }
  }

  /* æ·±è‰²æ¨¡å¼ä¼˜åŒ– */
  :global(.dark) .tag-card {
    background: var(--tag-bg);
  }

  :global(.dark) .tag-icon {
    background: rgba(30, 41, 59, 0.8);
  }

  :global(.dark) .tag-card:hover .tag-icon {
    background: var(--tag-text);
  }

  :global(.dark) .stat-item {
    background: rgba(30, 41, 59, 0.5);
  }
</style>
