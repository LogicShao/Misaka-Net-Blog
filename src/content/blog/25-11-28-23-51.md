---
title: '8086/8088 指令编码与中断系统核心知识点综述'
description: '深入剖析8086微处理器的指令集微观机制与中断处理流程。从MOV/LEA的物理差异到中断向量表的寻址逻辑，详解NEG/CMP指令对标志位的底层影响及INT 21H系统调用的本质。'
pubDate: 2025-11-28
tags: ['微机原理', '汇编语言', '中断系统', '指令集', '学习笔记']
draft: false
---

在微机原理的研究中，指令的寻址方式、数据传输的本质差异以及中断系统的层级结构是理解系统底层运作的关键。

## 数据传送与地址操作指令群辨析

在8086指令集中，数据传送（Data Transfer）与地址传送（Address Object Transfer）虽然目的都是将信息载入寄存器，但其操作数类型、对标志位的影响以及物理意义存在本质区别。特别是
`LEA`、`LDS`、`LES`与通用传送指令`MOV`，以及串操作指令`LODS`、`MOVS`，在实际工程应用中极易误用。

**地址获取与数据传送的本质差异**

`MOV`指令执行的是纯粹的数据复制操作，它将源操作数（Source）的内容（无论是立即数、寄存器值还是内存单元中的数据）按位拷贝至目的操作数（Destination）。而
`LEA`（Load Effective Address）指令并不传送内存单元中的实体数据，而是计算源操作数的**16位偏移地址（Offset）**
，并将其传送至指定的16位通用寄存器。换言之，`MOV AX, [BX]`传送的是BX指向内存单元中的内容，而`LEA AX, [BX]`
传送的是BX寄存器内的数值本身（即有效地址）。

`LDS`与`LES`则是更高级的地址指针加载指令，属于远指针（Far Pointer）操作。它们不仅加载16位的偏移地址到指定寄存器，同时会将内存中随后的16位段基址自动加载到
`DS`（数据段寄存器）或`ES`（附加段寄存器）中。这在处理跨段数据访问或C语言指针操作时至关重要。

**串操作指令的微观机制**

`LODS`（Load String）与`MOVS`（Move String）均属于隐式寻址指令，严重依赖`SI`（源变址寄存器）、`DI`（目的变址寄存器）以及`DF`
（方向标志位）。`LODS`仅涉及单操作数的数据流向，即从`DS:SI`指向的内存单元读取数据至累加器（AL或AX），主要用于逐字节/字分析字符串；而
`MOVS`则实现内存到内存的数据块传输（从`DS:SI`到`ES:DI`），通常配合`REP`前缀实现由硬件控制的高速批量拷贝。

**指令特性对比表**

| 指令助记符    | 全称与学术含义                | 操作对象             | 标志位影响 | 核心功能与差异点                                               |
|:---------|:-----------------------|:-----------------|:------|:-------------------------------------------------------|
| **MOV**  | Move Data              | Reg/Mem/Imm      | 无     | 基础数据复制。**注意**：不能实现Mem到Mem的直接传送。                        |
| **LEA**  | Load Effective Address | Reg, Mem         | 无     | 计算并获取**偏移地址**。常用于获取变量指针或进行快速算术运算（如 `LEA AX, [BX+SI]`）。 |
| **LDS**  | Load Pointer using DS  | Reg, Mem         | 无     | 32位指针加载。低16位存入Reg，高16位存入**DS**。                        |
| **LES**  | Load Pointer using ES  | Reg, Mem         | 无     | 32位指针加载。低16位存入Reg，高16位存入**ES**。                        |
| **LODS** | Load String            | AL/AX, [DS:SI]   | 无     | 将源串元素读入累加器，自动调整SI。                                     |
| **MOVS** | Move String            | [ES:DI], [DS:SI] | 无     | 将源串元素复制到目的串，自动调整SI和DI。需配对段寄存器（源DS，目ES）。                |

## 中断控制系统专业术语详解

中断系统是微处理器处理异步事件和异常的核心机制。在8086架构中，硬件信号、寄存器标志位与软件指令共同构成了复杂的中断处理逻辑。

**标志位与硬件引脚**

**TF (Trap Flag，陷阱标志)**：位于FLAGS寄存器中。当TF=1时，CPU进入**单步调试模式**
。每执行完一条指令，CPU自动产生一个类型为1的内部中断，这不仅是调试器（如Debug）实现单步跟踪的硬件基础，也是系统监控程序的核心机制。

**IF (Interrupt Enable Flag，中断允许标志)**：控制**可屏蔽中断**的全局开关。当IF=1时，CPU允许响应外部`INTR`
引脚的中断请求；当IF=0时，CPU忽略（屏蔽）该类请求。需要注意的是，IF对非屏蔽中断（NMI）及软件中断无效。

**INTR (Interrupt Request，可屏蔽中断请求)**
：CPU芯片上的输入引脚。外部设备（如键盘、打印机接口）通过中断控制器（如8259A）向此引脚发送高电平信号以请求服务。该请求是否被响应取决于IF标志位的状态。

**NMI (Non-Maskable Interrupt，非屏蔽中断)**：CPU芯片上的输入引脚。该引脚的中断请求具有极高优先级，且**不受IF标志位控制**
，CPU必须响应。通常用于处理掉电检测、内存奇偶校验错误等灾难性硬件故障。

**$\overline{\text{INTA}}$ (Interrupt Acknowledge，中断响应)**
：CPU芯片的输出引脚（低电平有效）。当CPU决定响应INTR请求时，会通过此引脚向8259A发送两个连续的负脉冲，通知外设接口将**中断类型码
**发送至数据总线上，以便CPU获取。

**软件指令与返回机制**

**INT n (Interrupt Instruction)**：软中断指令。CPU根据操作数`n`（0-255）查找中断向量表，模拟一次硬件中断过程。它常用于调用系统内核服务。

**INT 21H**：在MS-DOS环境下最著名的系统调用指令。它不是CPU本身的硬件特性，而是操作系统提供的功能入口（API），通过AH寄存器传递功能号来执行文件操作、IO控制等。

**RET (Return)**：子程序返回指令。仅从堆栈中弹出IP（近返回）或CS和IP（远返回），用于普通的`CALL`指令调用后的返回。它**不恢复**
标志寄存器。

**IRET (Interrupt Return)**：中断返回指令。必须用于中断服务子程序的末尾。它依次从堆栈中弹出**IP、CS和FLAGS**
寄存器。恢复FLAGS是其与RET的本质区别，确保了中断前的现场状态（包括中断允许状态）被完整复原。

## 中断向量表、类型码与服务子程序

这三个概念构成了中断处理的“索引-寻址-执行”链条。

**中断类型码 (Interrupt Type Code)** 是一个8位的无符号整数（0-255），用于标识中断源的身份。它既可以由软件指令直接给出（如
`INT 3`），也可以由硬件在中断响应周期通过数据总线提供。

**中断向量表 (Interrupt Vector Table, IVT)** 是存储在内存物理地址`00000H`至`003FFH`
区域的一个查找表。该表共1KB，包含256个表项，每个表项占4个字节。每个表项存放一个**中断向量**
，即中断服务子程序的入口地址（低2字节为偏移地址IP，高2字节为段基址CS）。CPU利用类型码 $n$
乘以4，计算出该类型中断向量在表中的物理地址（$4n$），从而读取入口地址。

**中断服务子程序 (Interrupt Service Routine, ISR)**
是实际处理中断事件的代码段。当CPU获取中断向量后，会跳转至ISR执行。ISR通常包含保护现场（PUSH）、处理具体事务、恢复现场（POP）以及执行
`IRET`返回主程序四个步骤。

## 中断分类体系与INT 0~4专用中断

中断按其产生来源和性质可进行严格分类，同时Intel为特定的系统异常预留了专用的中断类型。

**中断分类逻辑**

1. **来源分类**：

* **内部中断（异常/软件中断）**：由CPU执行指令过程中产生（如除法溢出、单步调试）或执行`INT n`指令引起。此类中断不可被屏蔽。
* **外部中断（硬件中断）**：由CPU外部电路通过INTR或NMI引脚触发。

2. **屏蔽特性分类**：

* **可屏蔽中断**：连接至INTR引脚，受IF标志位控制。
* **非屏蔽中断**：连接至NMI引脚，用于紧急硬件故障，不受IF限制。

**INT 0 ~ INT 4 专用中断定义**

Intel 8086架构保留了前5个中断类型码用于处理特定的CPU异常，不可被外部硬件占用：

* **INT 0 (除法出错)**：当执行`DIV`或`IDIV`指令时，若除数为0或商超过目标寄存器范围，CPU自动触发此中断。
* **INT 1 (单步中断)**：当TF=1时，每执行一条指令后触发。
* **INT 2 (非屏蔽中断)**：当NMI引脚检测到有效信号时触发。
* **INT 3 (断点中断)**：专用的单字节指令（机器码CC），用于软件调试中设置断点。
* **INT 4 (溢出中断)**：执行`INTO`指令时，若OF（溢出标志）=1，则触发此中断。

## 算术逻辑与比较指令的微观差异

在逻辑运算、补码操作及比较指令中，对操作数内容的修改方式及对标志位的影响是区分的关键。

**NEG, NOT 与 TEST**

* **NEG (Negate)**：算术指令，执行**求补**操作（0 - 操作数）。它将操作数视为带符号数，将其变号。**严重影响**CF, OF, SF, ZF, AF,
  PF所有状态标志位。
* **NOT**：逻辑指令，执行**按位取反**（1's Complement）。它仅修改操作数本身，**不影响任何标志位**。这是两者最大的区别。
* **TEST**：逻辑比较指令，执行**按位与**（AND）操作。关键在于它**不保存结果**，仅根据运算结果设置SF, ZF,
  PF标志位，并将CF和OF清零。常用于检测特定位是否为1（如 `TEST AL, 01H` 检测最低位）。

**比较指令群：CMP, SCAS, CMPS**

| 指令       | 运算逻辑                    | 操作数来源            | 典型应用场景                                      |
|:---------|:------------------------|:-----------------|:--------------------------------------------|
| **CMP**  | Sub (Dest - Src)        | 通用 (Reg/Mem/Imm) | **不修改操作数**，仅影响标志位。用于常规数值比较（如 `CMP AX, BX`）。 |
| **SCAS** | Sub (Acc - [ES:DI])     | 累加器(AL/AX) 与 目的串 | **扫描**。比较累加器中的值与目标字符串中的字符，查找特定字符。           |
| **CMPS** | Sub ([DS:SI] - [ES:DI]) | 源串 与 目的串         | **匹配**。逐字节/字比较两个内存区域的内容是否相等。                |

*注：SCAS和CMPS均会更新DI（及SI），且仅影响标志位，不保存减法结果。*

## 处理器控制与程序终止指令辨析

**HLT, NOP 与 DOS退出调用**

这三者代表了三种完全不同的CPU状态控制方式，混淆使用会导致程序跑飞或死锁。

1. **HLT (Halt)**：使CPU进入**暂停状态**
   。CPU停止取指和执行，总线处于空闲状态，以降低功耗。只有当发生外部中断（NMI或INTR且IF=1）或系统复位时，CPU才会被唤醒继续执行HLT之后的指令。它常用于等待中断的场景。

2. **NOP (No Operation)**：CPU执行该指令时不进行任何操作，仅消耗3个时钟周期，并使IP指向下一条指令。其机器码本质上是
   `XCHG AX, AX`。主要用于程序延时、指令对齐或作为预留代码空间的占位符（Patching）。

3. **MOV AX, 4C00H; INT 21H**：这是MS-DOS操作系统提供的**标准程序终止系统调用**。

* `MOV AH, 4CH`：指定DOS功能号“带返回码终止”。
* `AL = 00H`：指定返回给操作系统的错误码（0通常表示正常退出）。
* `INT 21H`：触发软中断，将控制权移交给操作系统。
* **差异**：`HLT`是挂起硬件等待唤醒，`RET`是子程序返回，只有此序列才是汇编程序结束运行、返回OS命令行的**正确且唯一**
  的标准方法。如果不使用此指令，程序执行完最后一条指令后会继续向下执行未定义的内存区域，导致系统崩溃。
